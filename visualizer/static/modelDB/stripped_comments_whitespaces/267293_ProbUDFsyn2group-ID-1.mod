NEURON{POINT_PROCESSProbUDFsyn2groupRANGEtau_r,tau_d,NsynsRANGEUse,u,Dep,Fac,u0RANGEi,g,e,gmaxNONSPECIFIC_CURRENTiPOINTERrng}PARAMETER{tau_r=0.2(ms)tau_d=1.7(ms)Use=1.0(1)Dep=100(ms)Fac=10(ms)e=0(mV)gmax=.001(uS)u0=0Nsyns=10}VERBATIM#include<stdlib.h>#include<stdio.h>#include<math.h>#ifndefNRN_VERSION_GTEQ_8_2_0doublenrn_random_pick(void*r);void*nrn_random_arg(intargpos);externintifarg(intiarg);externintvector_capacity(void*vv);externvoid*vector_arg(intiarg);#defineRANDCAST#else#defineRANDCAST(Rand*)#endifENDVERBATIMASSIGNED{v(mV)i(nA)g(uS)factorrngweight_NMDAspace}STATE{AB}INITIAL{LOCALtpA=0B=0tp=(tau_r*tau_d)/(tau_d-tau_r)*log(tau_d/tau_r)factor=-exp(-tp/tau_r)+exp(-tp/tau_d)factor=1/factor}BREAKPOINT{SOLVEstateMETHODcnexpg=gmax*(B-A)i=g*(v-e)}DERIVATIVEstate{A'=-A/tau_rB'=-B/tau_d}NET_RECEIVE(weight,Pv,Pr,u,myInd,tsyn(ms),Pv_tmp){INITIAL{Pv=1u=u0tsyn=t}VERBATIMvoid**vv=(void**)(&space);double*x;intnx=vector_instance_px(*vv,&x);intmyInd=rand()%((int)Nsyns);_args[4]=myInd;_args[5]=x[myInd];_args[1]=x[myInd+(int)Nsyns];_args[3]=x[myInd+2*((int)Nsyns)];ENDVERBATIMif(Fac>0){u=u*exp(-(t-tsyn)/Fac)}else{u=Use}if(Fac>0){u=u+Use*(1-u)}Pv_tmp=1-(1-Pv)*exp(-(t-tsyn)/Dep)Pr=u*Pv_tmpPv_tmp=Pv_tmp-u*Pv_tmpif(erand()<Pr){tsyn=tPv=Pv_tmpA=A+weight*factorB=B+weight*factor}else{}VERBATIMx[myInd]=_args[5];x[myInd+(int)Nsyns]=_args[1];x[myInd+2*((int)Nsyns)]=_args[3];ENDVERBATIM}PROCEDUREsetRNG(){VERBATIM{void**pv=(void**)(&_p_rng);if(ifarg(1)){*pv=nrn_random_arg(1);}else{*pv=(void*)0;}}ENDVERBATIM}FUNCTIONerand(){VERBATIMdoublevalue;if(_p_rng){value=nrn_random_pick(RANDCAST_p_rng);returnvalue;}else{ENDVERBATIMerand=exprand(1)VERBATIM}ENDVERBATIM}PROCEDUREsetVec(){VERBATIMvoid**vv;vv=(void**)(&space);*vv=(void*)0;if(ifarg(1)){*vv=vector_arg(1);Nsyns=vector_capacity(*vv)/3;}ENDVERBATIM}PROCEDUREprintVec(){VERBATIMvoid**vv=(void**)(&space);double*x;intnx=vector_instance_px(*vv,&x);inti1;for(i1=0;i1<Nsyns;i1++){printf("tsyns[%i]=%g,Pv[%i]=%g,u[%i]=%g\n",i1,x[i1],i1,x[i1+(nx/3)],i1,x[i1+2*(nx/3)]);}ENDVERBATIM}