NEURON{SUFFIXsnGLOBALINSTALLED,EUCLIDEAN,SQDIFF,CITYBLOCK}PARAMETER{INSTALLED=0EUCLIDEAN=0SQDIFF=1CITYBLOCK=2}VERBATIM#include"misc.h"doubleDMIN(doubled1,doubled2){returnd1<d2?d1:d2;}intIMIN(inti1,inti2){returni1<i2?i1:i2;}staticdoublemultall(void*vv){double*pv,dval=0.0;intn=vector_instance_px(vv,&pv),idx=0;if(n<1){printf("multallERRA:vectorsize<1!\n");return0.0;}dval=pv[0];for(idx=1;idx<n;idx++)dval*=pv[idx];returndval;}staticdoubleV_OR(void*vv){double*pV1,*pV2,*pV3;intn=vector_instance_px(vv,&pV1);if(vector_arg_px(1,&pV2)!=n||vector_arg_px(2,&pV3)!=n){printf("V_ORERRA:vecsmusthavesamesize%d!",n);return0.0;}inti;for(i=0;i<n;i++){pV1[i]=(pV2[i]||pV3[i])?1.0:0.0;}return1.0;}staticdoublesmooth(void*vv){inti,j,k,winsz,sz;doubles,cnt;double*pV1,*pV2;if(!ifarg(1)){printf("vec.smooth(vecout,smoothsize)\n");return0.0;}sz=vector_instance_px(vv,&pV1);if(vector_arg_px(1,&pV2)!=sz){printf("smoothERRA:vecsmusthavesamesize%d!",sz);return0.0;}if((winsz=(int)*getarg(2))<1){printf("smoothERRB:winszmustbe>=1:%d\n",winsz);return0.0;}for(i=0;i<winsz;i++)pV2[i]=pV1[i];cnt=winsz;i=0;j=winsz-1;s=0.0;for(k=i;k<=j;k++)s+=pV1[k];while(j<sz){pV2[j]=s/cnt;s-=pV1[i];i++;j++;s+=pV1[j];}return1.0;}staticdoubleposcount(void*vv){double*pV;intiSz=vector_instance_px(vv,&pV),i=0,iCount=0;for(i=0;i<iSz;i++)if(pV[i]>0.0)iCount++;return(double)iCount;}staticdoubleGetSpikeTimes(void*vv){double*pVolt,*pSpikeTimes;intn=vector_instance_px(vv,&pSpikeTimes);inttmp=vector_arg_px(1,&pVolt);if(tmp!=n){printf("GetSpikeTimesERRA:outputtimesvechasdiffsize%d%d\n",n,tmp);return0.0;}doubledThresh=*getarg(2);doubledMinTime=*getarg(3);doubledDipThresh=1.5*dThresh;doubleloc_dt=ifarg(4)?*getarg(4):dt;if(0)printf("dt=%f\n",dt);inti,iSpikes=0;for(i=0;i<n;i++){doubledVal=pVolt[i];if(dVal>=dThresh){if(iSpikes>0){if(loc_dt*i-pSpikeTimes[iSpikes-1]<dMinTime){continue;}}while(i+1<n){if(pVolt[i]>pVolt[i+1]){break;}i++;}pSpikeTimes[iSpikes++]=loc_dt*i;while(i<n){if(pVolt[i]<=dDipThresh){break;}i++;}}}vector_resize(vv,iSpikes);return(double)iSpikes;}staticdoublecountdbl(double*p,intiStartIDX,intiEndIDX,doubledval){intidx=iStartIDX,iCount=0;for(;idx<=iEndIDX;idx++)if(p[idx]==dval)iCount++;returniCount;}ENDVERBATIMFUNCTIONMeanCutDist(){VERBATIMdouble*p1,*p2,*p3;intn=vector_arg_px(1,&p1);if(n!=vector_arg_px(2,&p2)||n!=vector_arg_px(3,&p3)){printf("MeanCutDistERRA:vecsmustbesamesize!\n");return-1.0;}inti,iCount=0;doubledSum=0.0,dVal=0.0;for(i=0;i<n;i++){if(p3[i])continue;dVal=p1[i]-p2[i];dVal*=dVal;dSum+=dVal;iCount++;}if(iCount>0){dSum/=(double)iCount;returndSum;}printf("MeanCutDistWARNINGA:nosumstaken\n");return-1.0;ENDVERBATIM}FUNCTIONLDist(){VERBATIMObject*pList1=*hoc_objgetarg(1);Object*pList2=*hoc_objgetarg(2);if(!IsList(pList1)||!IsList(pList2)){printf("LDistERRA:Arg1&2mustbeLists!\n");return-1.0;}intiListSz1=ivoc_list_count(pList1),iListSz2=ivoc_list_count(pList2);if(iListSz1!=iListSz2||iListSz1<1){printf("LDistERRB:Listsmusthavesame>0size%d%d\n",iListSz1,iListSz2);return-1.0;}double**ppVecs1,**ppVecs2;ppVecs1=(double**)malloc(sizeof(double*)*iListSz1);ppVecs2=(double**)malloc(sizeof(double*)*iListSz2);if(!ppVecs1||!ppVecs2){printf("LDistERRRC:outofmemory!\n");if(ppVecs1)free(ppVecs1);if(ppVecs2)free(ppVecs2);return-1.0;}intiVecSz1=list_vector_px(pList1,0,&ppVecs1[0]);intiVecSz2=list_vector_px(pList2,0,&ppVecs2[0]);if(iVecSz1!=iVecSz2){free(ppVecs1);free(ppVecs2);printf("LDistERRD:vectorsmusthavesamesize%d%d!\n",iVecSz1,iVecSz2);return-1.0;}inti;for(i=1;i<iListSz1;i++){intiTmp1=list_vector_px(pList1,i,&ppVecs1[i]);intiTmp2=list_vector_px(pList2,i,&ppVecs2[i]);if(iTmp1!=iVecSz1||iTmp2!=iVecSz1){free(ppVecs1);free(ppVecs2);printf("LDistERRD:vectorsmusthavesamesize%d%d%d\n",iVecSz1,iTmp1,iTmp2);return-1.0;}}intj;doubledDist=0.0;doubledVal=0.0;doubledSum=0.0;intiType=0;if(ifarg(3))iType=*getarg(3);if(iType==EUCLIDEAN){for(i=0;i<iVecSz1;i++){dSum=0.0;for(j=0;j<iListSz1;j++){dVal=ppVecs1[j][i]-ppVecs2[j][i];dVal*=dVal;dSum+=dVal;}dDist+=sqrt(dSum);}}elseif(iType==SQDIFF){for(i=0;i<iVecSz1;i++){dSum=0.0;for(j=0;j<iListSz1;j++){dVal=ppVecs1[j][i]-ppVecs2[j][i];dVal*=dVal;dSum+=dVal;}dDist+=dSum;}}elseif(iType==CITYBLOCK){for(i=0;i<iVecSz1;i++){dSum=0.0;for(j=0;j<iListSz1;j++){dVal=ppVecs1[j][i]-ppVecs2[j][i];dSum+=dVal>=0.0?dVal:-dVal;}dDist+=dSum;}}else{printf("LDistERRE:invaliddistancetype%d!\n",iType);return-1.0;}free(ppVecs1);free(ppVecs2);returndDist;ENDVERBATIM}FUNCTIONSpikeTrainCoinc(){VERBATIMdouble*pVec1,*pVec2;intiSz1=vector_arg_px(1,&pVec1);intiSz2=vector_arg_px(2,&pVec2);doubledErr=-666.0;if(!pVec1||!pVec2){printf("SpikeTrainCoincERRA:Can'tgetvecargs1&2!\n");returndErr;}if(iSz1==0&&iSz2==0){printf("SpikeTrainCoincWARNA:bothspiketrainssizeof0\n");return0.0;}doubledBinSize=*getarg(3);if(dBinSize<=0.0){printf("SpikeTrainCoincERRB:binsizemustbe>0.0!\n");returndErr;}doubledStimDur=*getarg(4);if(dStimDur<=0.0){printf("SpikeTrainCoincERRC:stimdurmustbe>0.0!\n");returndErr;}doubledNumBins=dStimDur/dBinSize;inti=0,j=0;intiCoinc=0;doubledThresh=2.0;for(i=0;i<iSz1;i++){for(j=0;j<iSz2;j++){if(fabs(pVec1[i]-pVec2[i])<=dThresh){iCoinc++;break;}}}doubledN=1.0-((double)iSz1)/dNumBins;dN=1.0/dN;doubledRandCoinc=(iSz1*iSz2)/dNumBins;returndN*((((double)iCoinc)-dRandCoinc)/((iSz1+iSz2)/2.0));ENDVERBATIM}FUNCTIONStupidCopy(){VERBATIMdouble*pDest,*pSrc;intiSz1=vector_arg_px(1,&pDest);intiSz2=vector_arg_px(2,&pSrc);intiSrcStart=*getarg(3);intiSrcEnd=*getarg(4);inti,j=0;for(i=iSrcStart;i<iSrcEnd;i++,j++){pDest[j]=pSrc[i];}return1.0;ENDVERBATIM}FUNCTIONSpikeTrainEditDist(){VERBATIMdouble*pVec1=0x0,*pVec2=0x0;intiSz1=vector_arg_px(1,&pVec1);intiSz2=vector_arg_px(2,&pVec2);if(!pVec1||!pVec2){printf("SpikeTrainEditDistERRA:Can'tgetvecargs1&2!\n");return-1.0;}doubledMoveCost=ifarg(3)?*getarg(3):0.1;if(dMoveCost<0.0){printf("SpikeTrainEditDistERRB:movecostmustbe>=0!\n");return-1.0;}doubledDelCost=ifarg(4)?*getarg(4):1.0;if(dDelCost<0.0){printf("SpikeTrainEditDistERRC:deletecostmustbe>=0!\n");return-1.0;}if(dMoveCost==0.0)returnfabs(iSz1-iSz2)*dDelCost;elseif(dMoveCost>=9e24)return(double)(iSz1+iSz2)*dDelCost;if(iSz1<1)return(double)(iSz2*dDelCost);elseif(iSz2<1)return(double)(iSz1*dDelCost);double**dtab=(double**)malloc(sizeof(double*)*(iSz1+1));if(!dtab){printf("SpikeTrainEditDistERRD:outofmemory!\n");return-1.0;}introw,col;for(row=0;row<iSz1+1;row+=1){dtab[row]=(double*)malloc(sizeof(double)*(iSz2+1));if(!dtab[row]){printf("SpikeTrainEditDistERRE:outofmemory!\n");inttrow;for(trow=0;trow<row;trow++)free(dtab[trow]);free(dtab);return-1.0;}memset(dtab[row],0,sizeof(double)*(iSz2+1));}for(row=0;row<iSz1+1;row+=1)dtab[row][0]=(double)(row*dDelCost);for(col=0;col<iSz2+1;col+=1)dtab[0][col]=(double)(col*dDelCost);for(row=1;row<iSz1+1;row+=1){for(col=1;col<iSz2+1;col+=1){dtab[row][col]=DMIN(DMIN(dtab[row-1][col]+dDelCost,dtab[row][col-1]+dDelCost),dtab[row-1][col-1]+dMoveCost*fabs(pVec1[row-1]-pVec2[col-1]));}}doubledTotalCost=dtab[iSz1][iSz2];for(row=0;row<iSz1+1;row++)free(dtab[row]);free(dtab);returndTotalCost;ENDVERBATIM}PROCEDUREinstall(){if(INSTALLED==1){}else{INSTALLED=1VERBATIMinstall_vector_method("GetSpikeTimes",GetSpikeTimes);install_vector_method("V_OR",V_OR);install_vector_method("poscount",poscount);install_vector_method("multall",multall);install_vector_method("smooth",smooth);ENDVERBATIM}}