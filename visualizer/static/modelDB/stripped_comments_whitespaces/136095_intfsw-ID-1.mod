NEURON{SUFFIXintfswGLOBALINSTALLEDGLOBALverboseGLOBALedgefuncid}PARAMETER{INSTALLED=0verbose=0edgefuncid=0}VERBATIM#include"misc.h"typedefstruct{intisz;intimaxsz;double*p;}myvec;myvec*allocmyvec(intmaxsz){myvec*pv=(myvec*)malloc(sizeof(myvec));if(!pv)return0x0;pv->isz=0;pv->imaxsz=maxsz;pv->p=(double*)malloc(sizeof(double)*maxsz);if(!pv->p){free(pv);return0x0;}returnpv;}intfreemyvec(myvec**pps){if(!pps||!pps[0])return0;myvec*ps=pps[0];if(ps->p)free(ps->p);free(ps);pps[0]=0x0;return1;}doublepopmyvec(myvec*pv){if(pv->isz<1){printf("popmyvecERRA:can'tpopemptystack!\n");return0.0;}doubled=pv->p[pv->isz-1];pv->isz--;returnd;}voidpopallmyvec(myvec*pv){pv->isz=0;}doublepushmyvec(myvec*ps,doubled){if(ps->isz==ps->imaxsz){printf("pushmyvecrealloc\n");ps->imaxsz*=2;ps->p=(double*)realloc(ps->p,sizeof(double)*ps->imaxsz);if(!ps->p){printf("pushmyvecERRA:myvecoutofmemory%d!!\n",ps->imaxsz);return0.0;}}ps->p[ps->isz++]=d;return1.0;}doubleappendmyvec(myvec*ps,doubled){returnpushmyvec(ps,d);}typedefstructmyqnode_{structmyqnode_*pnext;structmyqnode_*pprev;intdd;}myqnode;myqnode*allocmyqnode(){myqnode*p=(myqnode*)malloc(sizeof(myqnode));p->pnext=0x0;p->pprev=0x0;returnp;}typedefstruct{myqnode*pfront;myqnode*pback;}myq;myq*allocmyq(){myq*pq=(myq*)malloc(sizeof(myq));pq->pfront=pq->pback=0x0;returnpq;}intfreemyq(myq**ppq){myq*pq=*ppq;myqnode*ptmp=pq->pback;while(pq->pback){if(pq->pback->pprev==0x0){free(pq->pback);pq->pback=0x0;pq->pfront=0x0;break;}else{ptmp=pq->pback->pprev;free(pq->pback);}}free(pq);ppq[0]=0;return1;}intprintfrontmyq(myq*pq){if(pq&&pq->pfront){printf("front=%d",pq->pfront->dd);return1;}printf("printfrontmyqERRA:emptyfront!\n");return0;}intprintbackmyq(myq*pq){if(pq&&pq->pback){printf("back=%d",pq->pback->dd);return1;}printf("printbackmyqERRA:emptyback!\n");return0;}intprintmyq(myq*pq,intbackwards){if(pq){inti=0;if(backwards){myqnode*pnode=pq->pback;while(pnode){printf("val%dfromback=%d\n",i++,pnode->dd);pnode=pnode->pprev;}}else{myqnode*pnode=pq->pfront;while(pnode){printf("val%dfromfront=%d\n",i++,pnode->dd);pnode=pnode->pnext;}}return1;}printf("printmyqERRA:nullpointer!\n");return0;}intenqmyq(myq*pq,intd){if(pq->pfront==pq->pback){if(!pq->pfront){pq->pfront=allocmyqnode();pq->pback=pq->pfront;pq->pfront->dd=d;}else{pq->pback=allocmyqnode();pq->pback->dd=d;pq->pback->pprev=pq->pfront;pq->pfront->pnext=pq->pback;}}else{myqnode*pnew=allocmyqnode();pnew->dd=d;pq->pback->pnext=pnew;pnew->pprev=pq->pback;pq->pback=pnew;}return1;}intemptymyq(myq*pq){if(pq->pfront==0x0)return1;return0;}intdeqmyq(myq*pq){if(pq->pfront==pq->pback){if(!pq->pfront){printf("deqmyqERRA:can'tdeqemptyq!\n");return-1.0;}else{intd=pq->pfront->dd;free(pq->pfront);pq->pfront=pq->pback=0x0;returnd;}}else{myqnode*tmp=pq->pfront;intd=tmp->dd;pq->pfront=pq->pfront->pnext;pq->pfront->pprev=0x0;free(tmp);returnd;}}ENDVERBATIMFUNCTIONtestmystack(){VERBATIMmyvec*pv=allocmyvec(10);printf("createdstackwithsz%d\n",pv->imaxsz);inti;for(i=0;i<pv->imaxsz;i++){doubled=41.0*(i%32)+rand()%100;printf("pushing%gontostackofsz%d\n",d,pv->isz);pushmyvec(pv,d);}printf("teststackreallocbypushing123.0\n");pushmyvec(pv,123.0);printf("stacknowhas%delements,%dmaxsz.contents:\n",pv->isz,pv->imaxsz);for(i=0;i<pv->isz;i++)printf("s[%d]=%g\n",i,pv->p[i]);printf("popping%delements.contents:\n",pv->isz);while(pv->isz){doubled=popmyvec(pv);printf("popped%g,newsz=%d\n",d,pv->isz);}printf("can'tpopstacknow,emptytest:");popmyvec(pv);freemyvec(&pv);printf("freedstack\n");return1.0;ENDVERBATIM}FUNCTIONtestmyq(){VERBATIMmyq*pq=allocmyq();printf("createdq,empty=%d\n",emptymyq(pq));printf("enqueing10values:\n");inti;for(i=0;i<10;i++){intd=41*(i%32)+rand()%252;printf("enqueuing%d...",d);enqmyq(pq,d);printfrontmyq(pq);printbackmyq(pq);printf("\n");}printf("printingqinforwardsorder:\n");printmyq(pq,0);printf("printingqinbackwardsorder:\n");printmyq(pq,1);printf("testingdeq:\n");while(!emptymyq(pq)){printf("b4deq:");printfrontmyq(pq);printbackmyq(pq);printf("\n");intd=deqmyq(pq);printf("dequeued%d\n",d);printf("afterdeq:");printfrontmyq(pq);printbackmyq(pq);printf("\n");}freemyq(&pq);printf("freedmyq\n");return1.0;ENDVERBATIM}VERBATIMstaticdoublecopynz(void*vv){double*pV;intn=vector_instance_px((IvocVect*)vv,&pV),iCount=0,idx=0;intiStartIDx=0,iEndIDx=n-1;if(ifarg(2)){iStartIDx=(int)*getarg(1);iEndIDx=(int)*getarg(2);}if(iEndIDx<iStartIDx||iStartIDx>=n||iEndIDx>=n||iStartIDx<0||iEndIDx<0){printf("copynzERRA:invalidindicesstart=%dend=%dsize=%d\n",iStartIDx,iEndIDx,n);return-1.0;}double*pVal,*pBin;if(vector_arg_px(1,&pVal)!=n||vector_arg_px(2,&pBin)!=n){printf("copynzERRB:vecargsmusthavesize%d!",n);return0.0;}intiOutSz=0;for(idx=iStartIDx;idx<=iEndIDx;idx++){if(pBin[idx]){pV[iOutSz++]=pVal[idx];}}vector_resize((IvocVect*)pV,iOutSz);return(double)iOutSz;}staticdoublennmeandbl(double*p,intiStartIDX,intiEndIDX){intiCount=0,idx=0;doubledSum=0.0;for(idx=iStartIDX;idx<=iEndIDX;idx++){if(p[idx]>=0.0){dSum+=p[idx];iCount++;}}if(iCount>0)returndSum/iCount;return-1.0;}staticdoublegzmeandbl(double*p,intiStartIDX,intiEndIDX){intiCount=0,idx=0;doubledSum=0.0;for(idx=iStartIDX;idx<=iEndIDX;idx++){if(p[idx]>0.0){dSum+=p[idx];iCount++;}}if(iCount>0)returndSum/iCount;return-1.0;}staticdoublegzmean(void*vv){double*pV;intn=vector_instance_px(vv,&pV),iCount=0,idx=0;intiStartIDx=0,iEndIDx=n-1;if(ifarg(2)){iStartIDx=(int)*getarg(1);iEndIDx=(int)*getarg(2);}if(iEndIDx<iStartIDx||iStartIDx>=n||iEndIDx>=n||iStartIDx<0||iEndIDx<0){printf("gzmeanERRA:invalidindicesstart=%dend=%dsize=%d\n",iStartIDx,iEndIDx,n);return-1.0;}returngzmeandbl(pV,iStartIDx,iEndIDx);}staticdoublennmean(void*vv){double*pV;intn=vector_instance_px(vv,&pV),iCount=0,idx=0;intiStartIDx=0,iEndIDx=n-1;if(ifarg(2)){iStartIDx=(int)*getarg(1);iEndIDx=(int)*getarg(2);}if(iEndIDx<iStartIDx||iStartIDx>=n||iEndIDx>=n||iStartIDx<0||iEndIDx<0){printf("nnmeanERRA:invalidindicesstart=%dend=%dsize=%d\n",iStartIDx,iEndIDx,n);return-1.0;}returnnnmeandbl(pV,iStartIDx,iEndIDx);}ENDVERBATIMFUNCTIONGetCCR(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetCCERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetCCERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;int*pNeighbors=(int*)calloc(iCells,sizeof(int));inti=0,iNeighbors=0;if(!pNeighbors){printf("GetCCRERRE:outofmemory!\n");FreeListVec(&pList);return0.0;}double*pCC;intiVecSz=vector_arg_px(2,&pCC);if(!pCC||iVecSz<iCells){printf("GetCCRERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pCC,0,sizeof(double)*iVecSz);intiStartID=ifarg(3)?(int)*getarg(3):0,iEndID=ifarg(4)?(int)*getarg(4):iCells-1;if(iStartID<0||iStartID>=iCells||iEndID<0||iEndID>=iCells||iStartID>=iEndID){printf("GetCCRERRH:invalididsstart=%dend=%dnumcells=%d\n",iStartID,iEndID,iCells);FreeListVec(&pList);free(pNeighbors);return0.0;}doubledSubsamp=ifarg(5)?*getarg(5):1.0;if(dSubsamp<0.0||dSubsamp>1.0){printf("GetCCRERRH:invalidsubsamp=%g,mustbebtwn0and1\n",dSubsamp);FreeListVec(&pList);free(pNeighbors);return0.0;}uint32_tiSeed=ifarg(7)?(uint32_t)*getarg(7):INT_MAX-109754;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}intmyID;int*pNeighborID=(int*)calloc(iCells,sizeof(int));if(verbose>0)printf("searchingfromid:");for(myID=0;myID<iCells;myID++)pCC[myID]=-1.0;for(myID=iStartID;myID<=iEndID;myID++){if(verbose>0&&myID%1000==0)printf("%d",myID);if(pUse&&pUse[myID]>=dSubsamp)continue;intidx=0,youID=0,youKidID=0,iNeighbors=0;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(youID>=iStartID&&youID<=iEndID){pNeighbors[youID]=1;pNeighborID[iNeighbors++]=youID;}}if(iNeighbors<2){for(i=0;i<iNeighbors;i++)pNeighbors[pNeighborID[i]]=0;continue;}intiConns=0;for(i=0;i<iNeighbors;i++){if(!pNeighbors[pNeighborID[i]])continue;youID=pNeighborID[i];for(idx=0;idx<pLen[youID];idx++){youKidID=pLV[youID][idx];if(youKidID>=iStartID&&youKidID<=iEndID&&pNeighbors[youKidID]){iConns++;}}}pCC[myID]=(double)iConns/((double)iNeighbors*(iNeighbors-1));for(i=0;i<iNeighbors;i++)pNeighbors[pNeighborID[i]]=0;}free(pNeighborID);free(pNeighbors);FreeListVec(&pList);if(pUse)free(pUse);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetCentrality(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetCentralityERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetCentralityERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pCE;intiVecSz=vector_arg_px(2,&pCE);if(!pCE||iVecSz<iCells){printf("GetCCRERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pCE,0,sizeof(double)*iVecSz);doubledSubsamp=ifarg(3)?*getarg(3):1.0;if(dSubsamp<0.0||dSubsamp>1.0){printf("GetCCRERRH:invalidsubsamp=%g,mustbebtwn0and1\n",dSubsamp);FreeListVec(&pList);return0.0;}uint32_tiSeed=ifarg(4)?(uint32_t)*getarg(4):INT_MAX-109754;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}ints,w,T,v,idx;myvec*S=allocmyvec(iCells*2);myvec**P=(myvec**)malloc(sizeof(myvec*)*iCells);myvec*d=allocmyvec(iCells);myvec*sigma=allocmyvec(iCells);myvec*di=allocmyvec(iCells);for(w=0;w<iCells;w++)P[w]=allocmyvec(iCells);for(s=0;s<iCells;s++){if(verbose&&s%100==0)printf("s=%d\n",s);S->isz=0;for(w=0;w<iCells;w++)P[w]->isz=0;for(T=0;T<iCells;T++)sigma->p[T]=0;sigma->p[s]=1;for(T=0;T<iCells;T++)d->p[T]=-1;d->p[s]=0;myq*Q=allocmyq();enqmyq(Q,s);while(!emptymyq(Q)){v=deqmyq(Q);pushmyvec(S,v);for(idx=0;idx<pLen[v];idx++){w=(int)pLV[v][idx];if(d->p[w]<0){enqmyq(Q,w);d->p[w]=d->p[v]+1;}if(d->p[w]==d->p[v]+1){sigma->p[w]=sigma->p[w]+sigma->p[v];appendmyvec(P[w],v);}}}freemyq(&Q);for(v=0;v<iCells;v++)di->p[v]=0;while(S->isz){w=popmyvec(S);for(idx=0;idx<P[w]->isz;idx++){v=P[w]->p[idx];di->p[v]=di->p[v]+(sigma->p[v]/sigma->p[w])*(1.0+di->p[w]);}if(w!=s)pCE[w]=pCE[w]+di->p[w];}}intN=0;for(s=0;s<iCells;s++)if(pLen[s])N++;if(N>2){doublescale=1.0/((N-1.0)*(N-2.0));for(v=0;v<iCells;v++)if(pLen[v])pCE[v]*=scale;}CEFREE:freemyvec(&S);for(w=0;w<iCells;w++)freemyvec(&P[w]);free(P);freemyvec(&d);freemyvec(&sigma);freemyvec(&di);if(pUse)free(pUse);return1.0;ENDVERBATIM}FUNCTIONGetCC(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetCCERRA:probleminitializingfirstarg!\n");return-1.0;}intiCells=pList->isz;if(iCells<2){printf("GetCCERRB:sizeofList<2!\n");FreeListVec(&pList);return-1.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;int*pNeighbors=(int*)calloc(iCells,sizeof(int));inti=0,iNeighbors=0;if(!pNeighbors){printf("GetCCERRE:outofmemory!\n");FreeListVec(&pList);return-1.0;}intmyID=(int)*getarg(2);if(myID<0||myID>=iCells){printf("GetCCERRF:invalidid=%d\n",myID);FreeListVec(&pList);free(pNeighbors);return-1.0;}intiStartID=ifarg(3)?(int)*getarg(3):0,iEndID=ifarg(4)?(int)*getarg(4):iCells-1;if(iStartID<0||iStartID>=iCells||iEndID<0||iEndID>=iCells||iStartID>=iEndID){printf("GetCCERRH:invalididsstart=%dend=%dnumcells=%d\n",iStartID,iEndID,iCells);FreeListVec(&pList);free(pNeighbors);return-1.0;}intidx=0,iDist=1,youID=0,youKidID=0;int*pNeighborID=(int*)calloc(iCells,sizeof(int));for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(youID>=iStartID&&youID<=iEndID){pNeighbors[youID]=1;pNeighborID[iNeighbors++]=youID;}}if(iNeighbors<2){FreeListVec(&pList);free(pNeighbors);return-1.0;}intiConns=0;for(i=0;i<iNeighbors;i++){if(!pNeighbors[pNeighborID[i]])continue;youID=pNeighborID[i];for(idx=0;idx<pLen[youID];idx++){youKidID=pLV[youID][idx];if(youKidID>=iStartID&&youKidID<=iEndID&&pNeighbors[youKidID]){iConns++;}}}free(pNeighborID);free(pNeighbors);FreeListVec(&pList);return(double)iConns/((double)iNeighbors*(iNeighbors-1));ENDVERBATIM}FUNCTIONCountNeighborsR(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("CountNeighborsRERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("CountNeighborsRERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pVD;intiVecSz=vector_arg_px(2,&pVD),i=0;if(!pVD||iVecSz<iCells){printf("CountNeighborsRERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pVD,0,sizeof(double)*iVecSz);intmyID=(int)*getarg(3);if(myID<0||myID>=iCells){printf("CountNeighborsRERRF:invalidid=%d\n",myID);FreeListVec(&pList);return0.0;}intiStartID=(int)*getarg(3),iEndID=(int)*getarg(4),iSearchDegree=(int)*getarg(5);doubledSubsamp=ifarg(6)?*getarg(6):1.0;uint32_tiSeed=ifarg(7)?(uint32_t)*getarg(7):INT_MAX-109754;if(iStartID<0||iStartID>=iCells||iEndID<0||iEndID>=iCells||iStartID>=iEndID){printf("CountNeighborsRERRH:invalididsstart=%dend=%dnumcells=%d\n",iStartID,iEndID,iCells);FreeListVec(&pList);return0.0;}if(iSearchDegree<=0){printf("CountNeighborsRERRI:invalidsearchdegree=%d\n",iSearchDegree);FreeListVec(&pList);return0.0;}int*pCheck=(int*)malloc(sizeof(int)*iCells);if(!pCheck){printf("CountNeighborsRERRG:outofmemory!\n");FreeListVec(&pList);return0.0;}intiCheckSz=0,idx=0,iDist=1,youID=0,youKidID=0,iTmpSz=0,jdx=0,iMatches=0;double*pVDTmp=0,dgzt=0.0;int*pTmp=0;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}if(verbose>0)printf("searchingfromid:");pVDTmp=(double*)calloc(iCells,sizeof(double));pTmp=(int*)calloc(iCells,sizeof(int));for(myID=iStartID;myID<=iEndID;myID++){if(verbose>0&&myID%1000==0)printf("%d",myID);if(pUse&&pUse[myID]>=dSubsamp)continue;iMatches=0;iCheckSz=0;idx=0;iDist=1;youID=0;youKidID=0;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(youID>=iStartID&&youID<=iEndID&&!pVDTmp[youID]){pVDTmp[youID]=(double)iDist;pCheck[iCheckSz++]=youID;}}if(iSearchDegree==iDist){pVD[myID]=iCheckSz;for(idx=0;idx<iCheckSz;idx++)pVDTmp[pCheck[idx]]=0;continue;}pVDTmp[myID]=1;iTmpSz=0;jdx=0;iDist++;while(iCheckSz>0&&iDist<=iSearchDegree){iTmpSz=0;for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){youKidID=pLV[youID][jdx];if(youKidID>=iStartID&&youKidID<=iEndID&&!pVDTmp[youKidID]){pTmp[iTmpSz++]=youKidID;pVDTmp[youKidID]=(double)iDist;}}}iCheckSz=iTmpSz;if(iSearchDegree==iDist){pVD[myID]=iCheckSz;memset(pVDTmp,0,sizeof(double)*iCells);break;}if(iCheckSz)memcpy(pCheck,pTmp,sizeof(int)*iCheckSz);iDist++;}}if(pUse)free(pUse);free(pCheck);FreeListVec(&pList);free(pVDTmp);free(pTmp);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}VERBATIMdoublemaxval(double*p,intsz){doubledmax=p[0];inti=1;for(;i<sz;i++)if(p[i]>dmax)dmax=p[i];returndmax;}doubleweightdelaydist(doublew,doubled){if(w<0)return-w/d;if(w>0)returnd/w;returnDBL_MAX;}doubleweightdist(doublew,doubled){if(w<0)return-w;if(w>0)return1/w;returnDBL_MAX;}doubledelaydist(doublew,doubled){returnd;}voidprintedgefunc(intid){switch(id){case0:printf("weightdelaydist\n");break;case1:printf("weightdist\n");break;case2:printf("delaydist\n");break;default:printf("unknown!\n");break;}}ENDVERBATIMFUNCTIONpredgefunc(){VERBATIMinti;if(ifarg(1)){printf("%d=",(int)*getarg(1));printedgefunc((int)*getarg(1));printf("\n");}elsefor(i=0;i<3;i++){printf("%d=",i);printedgefunc(i);printf("\n");}return0.0;ENDVERBATIM}FUNCTIONGetWPath(){VERBATIMdouble*ppre=0,*ppo=0,*pwght=0,*pdel=0,*pout=0;intiSz,iTmp,i,j,k,l;IvocVect*voi;iSz=vector_arg_px(1,&ppre);if(iSz<1){printf("GetWPathERRO:invalidsizeforpresynapticIDVector(arg1)%d!\n",iSz);return-666.666;}if((iTmp=vector_arg_px(2,&ppo))!=iSz){printf("GetWPathERRA:incorrectlysizedpostsynapticIDVector(arg2)%d%d!",iSz,iTmp);return-666.666;}if((iTmp=vector_arg_px(3,&pwght))!=iSz){printf("GetWPathERRB:incorrectlysizedweightVector(arg3)%d%d!\n",iSz,iTmp);return-666.666;}if((iTmp=vector_arg_px(4,&pdel))!=iSz){printf("GetWPathERRC:incorrectlysizeddelayVector(arg4)%d%d!\n",iSz,iTmp);return-666.666;}intmaxid=maxval(ppre,iSz);iTmp=maxval(ppo,iSz);if(iTmp>maxid)maxid=iTmp;voi=vector_arg(5);if((iTmp=vector_arg_px(5,&pout))!=maxid+1&&0){printf("GetWPathERRD:incorrectlysizedoutputVector(arg5)%d%d!\n",maxid+1,iTmp);return-666.666;}memset(pout,0,sizeof(double)*iTmp);double(*EdgeFunc)(double,double)=&weightdelaydist;intiEdgeFuncID=(int)edgefuncid;if(iEdgeFuncID<0||iEdgeFuncID>2){printf("GetWPathERRK:invalidedgedfuncid%d!\n",iEdgeFuncID);return-666.666;}elseif(iEdgeFuncID==1)EdgeFunc=&weightdist;elseif(iEdgeFuncID==2)EdgeFunc=&delaydist;if(verbose)printedgefunc(iEdgeFuncID);int**adj=(int**)calloc(maxid+1,sizeof(int*));if(!adj){printf("GetWPathERRE:outofmemory!\n");return-666.666;}double**pdist=(double**)calloc(maxid+1,sizeof(double*));int*pcounts=(int*)calloc(maxid+1,sizeof(int));for(i=0;i<iSz;i++){if(i+1<iSz&&ppre[i]==ppre[i+1]&&ppo[i]==ppo[i+1]){if(verbose>1)printf("firstcheckdoublesynapsei=%d\n",i);while(1){if(i+1>=iSz)break;if(ppre[i]!=ppre[i+1]||ppo[i]!=ppo[i+1]){i--;break;}i++;}}pcounts[(int)ppre[i]]++;}for(i=0;i<maxid+1;i++){if(pcounts[i]){adj[i]=(int*)calloc(pcounts[i],sizeof(int));pdist[i]=(double*)calloc(pcounts[i],sizeof(double));}}int*pidx=(int*)calloc(maxid+1,sizeof(int));for(i=0;i<iSz;i++){intmyID=(int)ppre[i];if(!pcounts[myID])continue;doubledist=EdgeFunc(pwght[i],pdel[i]);j=i;if(i+1<iSz&&ppre[i]==ppre[i+1]&&ppo[i]==ppo[i+1]){if(verbose>1)printf("checkdoublesyni=%d\n",i);while(1){if(i+1>=iSz)break;if(ppre[i]!=ppre[i+1]||ppo[i]!=ppo[i+1]){i--;break;}if(j!=i)dist+=EdgeFunc(pwght[i],pdel[i]);i++;}}pdist[myID][pidx[myID]]=dist;adj[myID][pidx[myID]]=ppo[i];pidx[myID]++;}free(pidx);double*d=(double*)malloc((maxid+1)*sizeof(double));for(i=0;i<=maxid;i++){if(i%100==0)printf("%d",i);if(!pcounts[i])continue;for(j=0;j<=maxid;j++)d[j]=DBL_MAX;d[i]=0.0;intchanged=0;for(j=0;j<maxid;j++){changed=0;for(k=0;k<=maxid;k++){for(l=0;l<pcounts[k];l++){if(d[adj[k][l]]>d[k]+pdist[k][l]){d[adj[k][l]]=d[k]+pdist[k][l];changed=1;}}}if(!changed){if(verbose>1)printf("earlyterm@j=%d\n",j);break;}}doubleavg=0.0;intN=0;for(j=0;j<=maxid;j++){if(j!=i&&d[j]<DBL_MAX){avg+=d[j];N++;}}if(N)pout[i]=avg/(double)N;}free(d);free(pcounts);for(i=0;i<=maxid;i++){if(adj[i])free(adj[i]);if(pdist[i])free(pdist[i]);}free(adj);free(pdist);vector_resize(voi,maxid+1);returngzmeandbl(pout,0,maxid);ENDVERBATIM}FUNCTIONGetPathR(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetPathEVERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetPathEVERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pVD;intiVecSz=vector_arg_px(2,&pVD),i=0;if(!pVD||iVecSz<iCells){printf("GetPathEVERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pVD,0,sizeof(double)*iVecSz);intiStartID=ifarg(3)?(int)*getarg(3):0,iEndID=ifarg(4)?(int)*getarg(4):iCells-1,iMaxDist=ifarg(5)?(int)*getarg(5):-1;doubledSubsamp=ifarg(6)?*getarg(6):1.0;uint32_tiSeed=ifarg(7)?(uint32_t)*getarg(7):INT_MAX-109754;if(iStartID<0||iStartID>=iCells||iEndID<0||iEndID>=iCells||iStartID>=iEndID){printf("GetPathEVERRH:invalididsstart=%dend=%dnumcells=%d\n",iStartID,iEndID,iCells);FreeListVec(&pList);return0.0;}if(iMaxDist==0){printf("GetPathEVERRI:invalidmaxdist=%d\n",iMaxDist);FreeListVec(&pList);return0.0;}int*pCheck;pCheck=(int*)malloc(sizeof(int)*iCells);if(!pCheck){printf("GetPathEVERRG:outofmemory!\n");FreeListVec(&pList);return0.0;}intiCheckSz=0,idx=0,iDist=1,youID=0,youKidID=0,iTmpSz=0,jdx=0;double*pVDTmp=0,dgzt=0.0;int*pTmp=0;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}pTmp=(int*)calloc(iCells,sizeof(int));if(verbose>0)printf("searchingfromid:");pVDTmp=(double*)calloc(iCells,sizeof(double));intmyID;for(myID=iStartID;myID<=iEndID;myID++){if(verbose>0&&myID%1000==0)printf("%d",myID);if(pUse&&pUse[myID]>=dSubsamp)continue;iCheckSz=0;idx=0;iDist=1;youID=0;youKidID=0;pVDTmp[myID]=1;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(youID>=iStartID&&youID<=iEndID&&!pVDTmp[youID]){pVDTmp[youID]=(double)iDist;pCheck[iCheckSz++]=youID;}}iTmpSz=0;jdx=0;iDist++;while(iCheckSz>0&&(iMaxDist==-1||iDist<=iMaxDist)){iTmpSz=0;for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){youKidID=pLV[youID][jdx];if(youKidID>=iStartID&&youKidID<=iEndID&&!pVDTmp[youKidID]){pTmp[iTmpSz++]=youKidID;pVDTmp[youKidID]=(double)iDist;}}}iCheckSz=iTmpSz;if(iCheckSz)memcpy(pCheck,pTmp,sizeof(int)*iCheckSz);iDist++;}pVDTmp[myID]=0.0;if((dgzt=gzmeandbl(pVDTmp,iStartID,iEndID))>0.0)pVD[myID]=dgzt;memset(pVDTmp,0,sizeof(double)*iCells);}free(pTmp);if(pUse)free(pUse);free(pCheck);FreeListVec(&pList);free(pVDTmp);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetCCSubPop(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetCCSubPopERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetCCSubPopERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;int*pNeighbors=(int*)calloc(iCells,sizeof(int));inti=0,iNeighbors=0;if(!pNeighbors){printf("GetCCSubPopERRE:outofmemory!\n");FreeListVec(&pList);return0.0;}double*pCC;intiVecSz=vector_arg_px(2,&pCC);if(!pCC||iVecSz<iCells){printf("GetCCSubPopERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pCC,0,sizeof(double)*iVecSz);double*pStart,*pEnd;if(vector_arg_px(3,&pStart)<iCells||vector_arg_px(4,&pEnd)<iCells){printf("GetCCSubPopERRF:arg3,4mustbeVectorswithsize>=%d\n",iCells);FreeListVec(&pList);return0.0;}doubledSubsamp=ifarg(5)?*getarg(5):1.0;unsignedintiSeed=ifarg(6)?(unsignedint)*getarg(6):INT_MAX-109754;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}intmyID;int*pNeighborID=(int*)calloc(iCells,sizeof(int));if(verbose>0)printf("searchingfromid:");for(myID=0;myID<iCells;myID++)pCC[myID]=-1.0;for(myID=0;myID<iCells;myID++){if(!pStart[myID])continue;if(verbose>0&&myID%1000==0)printf("%d",myID);if(pUse&&pUse[myID]>=dSubsamp)continue;intidx=0,youID=0,youKidID=0,iNeighbors=0;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(pEnd[youID]&&!pNeighbors[youID]){pNeighbors[youID]=1;pNeighborID[iNeighbors++]=youID;}}if(iNeighbors<2){for(i=0;i<iNeighbors;i++)pNeighbors[pNeighborID[i]]=0;continue;}intiConns=0;for(i=0;i<iNeighbors;i++){if(!pNeighbors[pNeighborID[i]])continue;youID=pNeighborID[i];for(idx=0;idx<pLen[youID];idx++){youKidID=pLV[youID][idx];if(pEnd[youKidID]&&pNeighbors[youKidID]){iConns++;}}}pCC[myID]=(double)iConns/((double)iNeighbors*(iNeighbors-1));for(i=0;i<iNeighbors;i++)pNeighbors[pNeighborID[i]]=0;}free(pNeighborID);free(pNeighbors);FreeListVec(&pList);if(pUse)free(pUse);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetRecurCount(){VERBATIMListVec*pList;unsignedint*pLen;intiCells,iFromSz,iThruSz,idx,myID,youID,jdx,iCheckSz,*pVisited,*pCheck;double**pLV,*pFrom,*pThru,*pR;pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetRecurCountERRA:probleminitializingfirstarg!\n");return0.0;}iCells=pList->isz;if(iCells<2){printf("GetRecurCountERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}pLV=pList->pv;pLen=pList->plen;pFrom=pThru=0;iFromSz=vector_arg_px(3,&pFrom);iThruSz=vector_arg_px(4,&pThru);if(iFromSz<=0||iThruSz<=0){printf("GetRecurCountERRF:arg3,4bad(fromsz,thrusz)=(%d,%d)\n",iFromSz,iThruSz);FreeListVec(&pList);return0.0;}pVisited=(int*)calloc(iCells,sizeof(int));pCheck=(int*)malloc(sizeof(int)*iCells);pR=vector_newsize(vector_arg(2),iCells);memset(pR,0,sizeof(double)*iCells);for(myID=0;myID<iCells;myID++){if(!pFrom[myID])continue;iCheckSz=0;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(!pThru[youID]||pVisited[youID])continue;pCheck[iCheckSz++]=youID;pVisited[youID]=1;}for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){if(pLV[youID][jdx]==myID)pR[myID]++;}}memset(pVisited,0,sizeof(int)*iCells);}free(pCheck);FreeListVec(&pList);free(pVisited);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetPairDist(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetPairDistERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetPairDistERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pFrom=0,*pTo=0;intiFromSz=vector_arg_px(3,&pFrom),iToSz=vector_arg_px(4,&pTo);if(iFromSz<=0||iToSz<=0){printf("GetPairDistERRF:arg3,4bad(fromsz,tosz)=(%d,%d)\n",iFromSz,iToSz);FreeListVec(&pList);return0.0;}intiMinSz=iFromSz*iToSz;double*pVD;pVD=vector_newsize(vector_arg(2),iMinSz);memset(pVD,0,sizeof(double)*iMinSz);int*pCheck;pCheck=(int*)malloc(sizeof(int)*iCells);if(!pCheck){printf("GetPairDistERRG:outofmemory!\n");FreeListVec(&pList);return0.0;}intiCheckSz=0,idx=0,iDist=1,youID=0,youKidID=0,iTmpSz=0,jdx=0;int*pTmp=(int*)calloc(iCells,sizeof(int));if(verbose>0)printf("searchingfromid:");intmyID,iOff=0,kdx=0;int*pVisited=(int*)calloc(iCells,sizeof(int));int*pUse=(int*)calloc(iCells,sizeof(int));int*pMap=(int*)calloc(iCells,sizeof(int));for(idx=0;idx<iToSz;idx++){pUse[(int)pTo[idx]]=1;pMap[(int)pTo[idx]]=idx;}for(kdx=0;kdx<iFromSz;kdx++,iOff+=iToSz){myID=pFrom[kdx];if(verbose>0&&myID%100==0)printf("%d\n",myID);iCheckSz=0;idx=0;iDist=1;youID=0;youKidID=0;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(pUse[youID])pVD[iOff+pMap[youID]]=1;if(!pVisited[youID]){pCheck[iCheckSz++]=youID;pVisited[youID]=1;}}iTmpSz=0;jdx=0;iDist++;while(iCheckSz>0){iTmpSz=0;for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){youKidID=pLV[youID][jdx];if(pUse[youKidID]&&!pVD[iOff+pMap[youKidID]])pVD[iOff+pMap[youKidID]]=iDist;if(!pVisited[youKidID]){pTmp[iTmpSz++]=youKidID;pVisited[youKidID]=1;}}}iCheckSz=iTmpSz;if(iCheckSz)memcpy(pCheck,pTmp,sizeof(int)*iCheckSz);iDist++;}memset(pVisited,0,sizeof(int)*iCells);}free(pTmp);free(pCheck);FreeListVec(&pList);free(pUse);free(pMap);free(pVisited);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetPathSubPop(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetPathEVERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetPathEVERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pVD;intiVecSz=vector_arg_px(2,&pVD),i=0;if(!pVD||iVecSz<iCells){printf("GetPathEVERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pVD,0,sizeof(double)*iVecSz);double*pStart,*pEnd;if(vector_arg_px(3,&pStart)<iCells||vector_arg_px(4,&pEnd)<iCells){printf("GetPathSubPopERRF:arg3,4mustbeVectorswithsize>=%d\n",iCells);FreeListVec(&pList);return0.0;}doubledSubsamp=ifarg(5)?*getarg(5):1.0;intbSelfLoop=ifarg(6)?(int)*getarg(6):0;uint32_tiSeed=ifarg(7)?(uint32_t)*getarg(7):INT_MAX-109754;int*pCheck=(int*)malloc(sizeof(int)*iCells);if(!pCheck){printf("GetPathEVERRG:outofmemory!\n");FreeListVec(&pList);return0.0;}intiCheckSz=0,idx=0,iDist=1,youID=0,youKidID=0,iTmpSz=0,jdx=0;doubledgzt=0.0;int*pTmp=0;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}pTmp=(int*)calloc(iCells,sizeof(int));if(verbose>0)printf("searchingfromid:");int*pVDTmp=(int*)calloc(iCells,sizeof(int)),myID;for(myID=0;myID<iCells;myID++){if(!pStart[myID])continue;if(verbose>0&&myID%1000==0)printf("%d",myID);if(pUse&&pUse[myID]>=dSubsamp)continue;unsignedlongintiSelfLoopDist=LONG_MAX;intbFindThisSelfLoop=bSelfLoop&&pEnd[myID];iCheckSz=0;idx=0;iDist=1;youID=0;youKidID=0;pVDTmp[myID]=1;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(bFindThisSelfLoop&&youID==myID&&iDist<iSelfLoopDist)iSelfLoopDist=iDist;if(!pVDTmp[youID]){pVDTmp[youID]=iDist;pCheck[iCheckSz++]=youID;}}iTmpSz=0;jdx=0;iDist++;while(iCheckSz>0){iTmpSz=0;for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){youKidID=pLV[youID][jdx];if(bFindThisSelfLoop&&youKidID==myID&&iDist<iSelfLoopDist)iSelfLoopDist=iDist;if(!pVDTmp[youKidID]){pTmp[iTmpSz++]=youKidID;pVDTmp[youKidID]=iDist;}}}iCheckSz=iTmpSz;if(iCheckSz)memcpy(pCheck,pTmp,sizeof(int)*iCheckSz);iDist++;}if(bFindThisSelfLoop&&iSelfLoopDist<LONG_MAX){pVDTmp[myID]=iSelfLoopDist;}else{pVDTmp[myID]=0;}pVD[myID]=0.0;intN=0;for(idx=0;idx<iCells;idx++){if(pEnd[idx]&&pVDTmp[idx]){pVD[myID]+=pVDTmp[idx];N++;}}if(N)pVD[myID]/=(double)N;memset(pVDTmp,0,sizeof(int)*iCells);}free(pTmp);if(pUse)free(pUse);free(pCheck);FreeListVec(&pList);free(pVDTmp);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetLoopLength(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetLoopLengthERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetLoopLengthERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pVD;intiVecSz=vector_arg_px(2,&pVD),i=0;if(!pVD||iVecSz<iCells){printf("GetLoopLengthERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pVD,0,sizeof(double)*iVecSz);double*pLoop,*pThru;if(vector_arg_px(3,&pLoop)<iCells||vector_arg_px(4,&pThru)<iCells){printf("GetLoopLengthERRF:arg3,4mustbeVectorswithsize>=%d\n",iCells);FreeListVec(&pList);return0.0;}doubledSubsamp=ifarg(5)?*getarg(5):1.0;uint32_tiSeed=ifarg(6)?(uint32_t)*getarg(6):INT_MAX-109754;int*pCheck=(int*)malloc(sizeof(int)*iCells);if(!pCheck){printf("GetLoopLengthERRG:outofmemory!\n");FreeListVec(&pList);return0.0;}intiCheckSz=0,idx=0,iDist=1,youID=0,youKidID=0,iTmpSz=0,jdx=0;doubledgzt=0.0;int*pTmp=0,found=0;double*pUse=0;if(dSubsamp<1.0){pUse=(double*)malloc(iCells*sizeof(double));mcell_ran4(&iSeed,pUse,iCells,1.0);}pTmp=(int*)calloc(iCells,sizeof(int));if(verbose>0)printf("searchingloopsfromid:");int*pVDTmp=(int*)calloc(iCells,sizeof(int)),myID;for(myID=0;myID<iCells;myID++){if(!pLoop[myID])continue;if(verbose>0&&myID%1000==0)printf("%d",myID);if(pUse&&pUse[myID]>=dSubsamp)continue;iCheckSz=0;idx=0;iDist=1;youID=0;youKidID=0;found=0;pVDTmp[myID]=1;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(youID==myID){found=1;pVD[myID]=iDist;iCheckSz=0;break;}if(pThru[youID]&&!pVDTmp[youID]){pVDTmp[youID]=iDist;pCheck[iCheckSz++]=youID;}}iTmpSz=0;jdx=0;iDist++;while(iCheckSz>0){iTmpSz=0;for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){youKidID=pLV[youID][jdx];if(youKidID==myID){pVD[myID]=iDist;found=1;break;}if(pThru[youKidID]&&!pVDTmp[youKidID]){pTmp[iTmpSz++]=youKidID;pVDTmp[youKidID]=iDist;}}}if(found)break;iCheckSz=iTmpSz;if(iCheckSz)memcpy(pCheck,pTmp,sizeof(int)*iCheckSz);iDist++;}memset(pVDTmp,0,sizeof(int)*iCells);}free(pTmp);if(pUse)free(pUse);free(pCheck);FreeListVec(&pList);free(pVDTmp);if(verbose>0)printf("\n");return1.0;ENDVERBATIM}FUNCTIONGetPathEV(){VERBATIMListVec*pList=AllocListVec(*hoc_objgetarg(1));if(!pList){printf("GetPathEVERRA:probleminitializingfirstarg!\n");return0.0;}intiCells=pList->isz;if(iCells<2){printf("GetPathEVERRB:sizeofList<2!\n");FreeListVec(&pList);return0.0;}double**pLV=pList->pv;unsignedint*pLen=pList->plen;double*pVD;intiVecSz=vector_arg_px(2,&pVD),i=0;if(!pVD||iVecSz<iCells){printf("GetPathEVERRE:arg2mustbeaVectorwithsize%d\n",iCells);FreeListVec(&pList);return0.0;}memset(pVD,0,sizeof(double)*iVecSz);intmyID=(int)*getarg(3);if(myID<0||myID>=iCells){printf("GetPathEVERRF:invalidid=%d\n",myID);FreeListVec(&pList);return0.0;}intiStartID=ifarg(4)?(int)*getarg(4):0,iEndID=ifarg(5)?(int)*getarg(5):iCells-1,iMaxDist=ifarg(6)?(int)*getarg(6):-1;if(iStartID<0||iStartID>=iCells||iEndID<0||iEndID>=iCells||iStartID>=iEndID){printf("GetPathEVERRH:invalididsstart=%dend=%dnumcells=%d\n",iStartID,iEndID,iCells);FreeListVec(&pList);return0.0;}if(iMaxDist==0){printf("GetPathEVERRI:invalidmaxdist=%d\n",iMaxDist);FreeListVec(&pList);return0.0;}int*pCheck=(int*)malloc(sizeof(int)*iCells);if(!pCheck){printf("GetPathEVERRG:outofmemory!\n");FreeListVec(&pList);return0.0;}intiCheckSz=0,idx=0,iDist=1,youID=0,youKidID=0;pVD[myID]=1;for(idx=0;idx<pLen[myID];idx++){youID=pLV[myID][idx];if(youID>=iStartID&&youID<=iEndID&&!pVD[youID]){pVD[youID]=(double)iDist;pCheck[iCheckSz++]=youID;}}int*pTmp=(int*)malloc(sizeof(int)*iCells);intiTmpSz=0,jdx=0;iDist++;while(iCheckSz>0&&(iMaxDist==-1||iDist<=iMaxDist)){iTmpSz=0;for(idx=0;idx<iCheckSz;idx++){youID=pCheck[idx];for(jdx=0;jdx<pLen[youID];jdx++){youKidID=pLV[youID][jdx];if(youKidID>=iStartID&&youKidID<=iEndID&&!pVD[youKidID]){pTmp[iTmpSz++]=youKidID;pVD[youKidID]=(double)iDist;}}}iCheckSz=iTmpSz;if(iCheckSz)memcpy(pCheck,pTmp,sizeof(int)*iCheckSz);iDist++;}pVD[myID]=0.0;free(pCheck);free(pTmp);FreeListVec(&pList);return1.0;ENDVERBATIM}FUNCTIONFactorial(){VERBATIMdoubleN=(int)*getarg(1),i=0.0;doubleval=1.0;if(N<=1)return1.0;if(N>=171){doublePI=3.1415926535897932384626433832795;doubleE=2.71828183;val=sqrt(2*PI*N)*(pow(N,N)/pow(E,N));}else{for(i=2.0;i<=N;i++)val*=i;}return(double)val;ENDVERBATIM}FUNCTIONperm(){VERBATIMif(ifarg(3)){doubleN=(int)*getarg(1);doubleR=(int)*getarg(2);doubleb=*getarg(3);doubleval=N/b;inti=0;for(i=1;i<R;i++){N--;val*=(N/b);}returnval;}else{intN=(int)*getarg(1);intR=(int)*getarg(2);intval=N;inti=0;for(i=1;i<R;i++){N--;val*=N;}return(double)val;}ENDVERBATIM}PROCEDUREinstall(){if(INSTALLED==1){printf("Alreadyinstalled$Id}else{INSTALLED=1VERBATIMinstall_vector_method("gzmean",gzmean);install_vector_method("nnmean",nnmean);install_vector_method("copynz",copynz);ENDVERBATIMprintf("Installed$Id}}