NEURON{SUFFIXnothingGLOBALROWS,COLS}PARAMETER{MATRIX_INSTALLED=0}ASSIGNED{ROWSCOLS}VERBATIM#include"misc.h"ENDVERBATIMVERBATIMstaticdoublesymmclean(void*vv){intix,dg,cols,i,j,n,flag,nx;double*x,*d;nx=vector_instance_px(vv,&x);cols=(ifarg(1)?((int)*getarg(1)):(int)COLS);flag=(ifarg(2)?(int)*getarg(2):0);d=dcrset(nx);for(i=0;i<nx;i++){if(x[i]!=floor(x[i])||x[i]<0.||x[i]>cols*cols){printf("symmcleanERR:OOB%g(%dx%d)\n",x[i],cols,cols);return-1;}ix=(int)x[i];dg=(n=ix/(cols+1))*(cols+1);if(ix<dg||ix>=dg+(cols-n)||(flag&&ix==dg))x[i]=-1;}for(i=0,j=0;i<nx;i++)if(x[i]!=-1)d[j++]=x[i];for(i=0;i<j;i++)x[i]=d[i];vector_resize((IvocVect*)vv,j);return(double)j;}ENDVERBATIMVERBATIMstaticdoubleoutprod(void*vv){inti,j,nx,ny,nz;double*x,*y,*z;nx=vector_instance_px(vv,&x);COLS=ny=vector_arg_px(1,&y);ROWS=nz=vector_arg_px(2,&z);if(nx!=ny*nz){hoc_execerror("Vectorsizemismatch",0);}for(i=0;i<ny;i++){for(j=0;j<nz;j++){x[i*nz+j]=y[i]*z[j];}}returnnx;}ENDVERBATIMVERBATIMstaticdoublemmult(void*vv){inti,j,nx,ny,nz;double*x,*y,*z;nx=vector_instance_px(vv,&x);ny=vector_arg_px(1,&y);nz=vector_arg_px(2,&z);if(ny!=nx*nz){hoc_execerror("Vectorsizemismatch",0);}for(i=0;i<nx;i++){x[i]=0.;for(j=0;j<nz;j++){x[i]+=y[i*nz+j]*z[j];}}returnnx;}ENDVERBATIMVERBATIMstaticdoublespltp(void*vv){intii,jj,nstpr,nstpo,nw,npr,npo,flag,cnt;double*stpr,*stpo,*w,*pr,*po;externdoublehoc_call_func(Symbol*,intnarg);charfunc[4]="ltp";Symbol*s=hoc_lookup(func);if(!s){hoc_execerror("Can'tfindltp()func",0);}nstpo=vector_instance_px(vv,&stpo);npr=vector_arg_px(1,&pr);npo=vector_arg_px(2,&po);nw=vector_arg_px(3,&w);nstpr=vector_arg_px(4,&stpr);for(ii=0,jj=0,cnt=0;ii<nstpo;ii++){if(stpo[ii]==1.0){for(;po[jj]<ii;jj++);for(;po[jj]==ii;jj++){if(stpr[(int)pr[jj]]==1.){cnt++;hoc_pushx(1.0);}else{cnt--;hoc_pushx(-1.0);}hoc_pushx(w[jj]);w[jj]=hoc_call_func(s,2);}}}returncnt;}ENDVERBATIMVERBATIMstaticint*pr_int;staticint*po_int;staticintcpfl=0;ENDVERBATIMVERBATIMstaticdoublemkspcp(void*vv){intj,nw,npr,npo;double*w,*pr,*po;if(!ifarg(1)){cpfl=0;if(po_int!=NULL)free(po_int);if(pr_int!=NULL)free(pr_int);po_int=(int*)NULL;pr_int=(int*)NULL;return0;}nw=vector_instance_px(vv,&w);npr=vector_arg_px(1,&pr);npo=vector_arg_px(2,&po);pr_int=(int*)ecalloc(nw,sizeof(int));po_int=(int*)ecalloc(nw,sizeof(int));for(j=0;j<nw;j++){po_int[j]=(int)po[j];pr_int[j]=(int)pr[j];}cpfl=nw;returncpfl;}ENDVERBATIMVERBATIMstaticdoublechkspcp(void*vv){intj,nw,npr,npo,flag;double*w,*pr,*po;nw=vector_instance_px(vv,&w);npr=vector_arg_px(1,&pr);npo=vector_arg_px(2,&po);flag=1;if(po_int==NULL||pr_int==NULL){cpfl=0;return0;}if(cpfl!=nw){flag=0;}elsefor(j=0;j<nw;j++){if(po_int[j]!=(int)po[j]||pr_int[j]!=(int)pr[j]){flag=0;continue;}}if(flag==0){cpfl=0;free(po_int);free(pr_int);po_int=(int*)NULL;pr_int=(int*)NULL;}returnflag;}ENDVERBATIMVERBATIMstaticdoublespmult(void*vv){inti,j,nx,ny,nw,npr,npo,flag;double*x,*y,*w,*pr,*po,xx;ny=vector_instance_px(vv,&y);npr=vector_arg_px(1,&pr);npo=vector_arg_px(2,&po);nw=vector_arg_px(3,&w);nx=vector_arg_px(4,&x);if(ifarg(5)){flag=1;}else{flag=0;}if(nw!=npr||nw!=npo){hoc_execerror("Sparsematmusthave3identicalsizevecsforpre/post/wt",0);}if(flag==0)for(i=0;i<ny;i++)y[i]=0.;if(cpfl==0){for(j=0;j<nw;j++)y[(int)po[j]]+=(x[(int)pr[j]]*w[j]);}elseif(cpfl!=nw){hoc_execerror("cpfl!=nwinspmult",0);}else{for(j=0;j<nw;j++)if(x[pr_int[j]]!=0){y[po_int[j]]+=((x[pr_int[j]])*w[j]);}}returnnx;}ENDVERBATIMVERBATIMstaticdoublespget(void*vv){intj,nw,npr,npo;double*w,*pr,*po,row,col;nw=vector_instance_px(vv,&w);npr=vector_arg_px(1,&pr);npo=vector_arg_px(2,&po);row=*getarg(3);col=*getarg(4);for(j=0;j<nw;j++)if(row==po[j]&&col==pr[j])break;if(j==nw)return0.;elsereturnw[j];}ENDVERBATIMFUNCTIONspidget(){VERBATIM{intj,npr,npo,nprid,npoid;double*pr,*po,*prid,*poid,pri,poi,pridi,poidi;npr=vector_arg_px(1,&pr);npo=vector_arg_px(2,&po);nprid=vector_arg_px(3,&prid);npoid=vector_arg_px(4,&poid);pri=*getarg(5);poi=*getarg(6);pridi=*getarg(7);poidi=*getarg(8);for(j=0;j<npr;j++){if(poi==po[j]&&pri==pr[j]&&pridi==prid[j]&&poidi==poid[j])break;}if(j==npr)_lspidget=-1.0;else_lspidget=(double)j;}ENDVERBATIM}VERBATIMstaticdoubletranspose(void*vv){inti,j,nx,ny,rows,cols,flag;double*x,*y;nx=vector_instance_px(vv,&x);if(ifarg(2)){ny=vector_arg_px(1,&y);COLS=cols=(ifarg(2))?(int)*getarg(2):(int)COLS;if(ny!=nx)hoc_execerror("Vectorsizemismatch",0);flag=0;}else{COLS=cols=(ifarg(1))?(int)*getarg(1):(int)COLS;y=(double*)ecalloc(nx,sizeof(double));flag=1;}ROWS=rows=nx/cols;if(flag){for(i=0;i<rows;i++)for(j=0;j<cols;j++)y[j*rows+i]=x[i*cols+j];for(i=0;i<nx;i++)x[i]=y[i];free(y);}else{for(i=0;i<rows;i++)for(j=0;j<cols;j++)x[j*rows+i]=y[i*cols+j];}ROWS=cols;COLS=rows;returnnx;}ENDVERBATIMVERBATIMstaticdoublerevrows(void*vv){inti,j,k,nx,rows,cols;double*x,tmp;nx=vector_instance_px(vv,&x);COLS=cols=(ifarg(1))?(int)*getarg(1):(int)COLS;ROWS=rows=nx/cols;for(i=0;i<rows/2;i++){k=rows-i-1;for(j=0;j<cols;j++){tmp=x[i*cols+j];x[i*cols+j]=x[k*cols+j];x[k*cols+j]=tmp;}}returnnx;}ENDVERBATIMVERBATIMstaticdoublemprintf(void*vv){inti,j,nx,rows,cols,rbeg,cbeg,prows,pcols,pfl;char*format;double*x;nx=vector_instance_px(vv,&x);i=1;rbeg=cbeg=pfl=0;prows=rows=(int)ROWS;pcols=cols=(int)COLS;if(ifarg(i)){if(!hoc_is_str_arg(i)){ROWS=prows=rows=(int)*getarg(i++);COLS=pcols=cols=(int)*getarg(i++);}if(ifarg(i)&&hoc_is_str_arg(i)){pfl=1;format=gargstr(i++);}if(ifarg(i))prows=(int)*getarg(i++);if(ifarg(i))pcols=(int)*getarg(i++);if(ifarg(i)){rbeg=prows;prows=(int)*getarg(i++);}if(ifarg(i)){cbeg=pcols;pcols=(int)*getarg(i++);}}if(nx!=rows*cols){printf("Vectorsizemismatch");hxe();}if(prows>rows||pcols>cols){printf("Prsizemismatch:%d%d%d%d",prows,rows,pcols,cols);hxe();}for(i=rbeg;i<prows;i++){for(j=cbeg;j<pcols;j++){if(pfl)printf(format,x[i*cols+j]);elseprintf("%g\t",x[i*cols+j]);}printf("\n");}returnnx;}ENDVERBATIMVERBATIMstaticdoublemshuffle(void*vv){inti,j,k,n,nx,rows,cols;double*x,y[1],temp,augstep;nx=vector_instance_px(vv,&x);COLS=cols=(ifarg(1))?(int)*getarg(1):(int)COLS;ROWS=(double)nx/COLS;if(ROWS!=floor(ROWS)){printf("matrixmshuffleROW/COLERR%g%g%d\n",ROWS,COLS,nx);hxe();}rows=ROWS;for(i=0;i<nx;i+=cols)dshuffle(x+i,cols);return(double)nx;}ENDVERBATIMVERBATIMstaticdoublesector(void*vv){inti,j,ii,jj,kk,nx,rows,cols,widx,widy,nm,err;double*x,*m;nx=vector_instance_px(vv,&x);nm=vector_arg_px(1,&m);i=(int)*getarg(2);j=(int)*getarg(3);widx=(int)*getarg(4);if(ifarg(6)){widy=(int)*getarg(5);cols=(int)*getarg(6);}else{widy=widx;cols=(int)*getarg(5);}err=0;ROWS=rows=nm/cols;if(nx!=widx*widy){printf("sector()ERRA:Vectorsizemismatch:%d%d\n",nx,widx*widy);hxe();}for(ii=0,kk=0;ii<widy&&!err;ii++)for(jj=0;jj<widx&&!err;jj++){if((i+ii)>rows||(j+jj)>cols){printf("WARN:felloffedge:%d%d%d%d\n",(i+ii),rows,(j+jj),cols);err=1;}x[kk++]=m[(i+ii)*cols+(j+jj)];}returnx[i*cols+j];}ENDVERBATIMVERBATIMstaticdoubleppmrd(void*vv){intcode,ii,type,num,maxsz,rows,cols,max,a,b,c;chartstr[256];double*x;FILE*f;num=vector_instance_px(vv,&x);maxsz=vector_buffer_size((IvocVect*)vv);f=hoc_obj_file_arg(1);fgets(tstr,256,f);sscanf(tstr,"P%d",&type);fgets(tstr,256,f);fgets(tstr,256,f);sscanf(tstr,"%d%d",&cols,&rows);printf("Reading%drowsx%dcols\n",rows,cols);fgets(tstr,256,f);sscanf(tstr,"%d",&max);if(maxsz<rows*cols){printf("ppmrdvectoosmall%d%d.",maxsz,rows*cols);hxe();}vector_resize((IvocVect*)vv,rows*cols);switch(type){case3:ii=0;while(fscanf(f,"%d%d%d",&a,&b,&c)==3)x[ii++]=(double)(a*65536+b*256+c);if(ii!=rows*cols){printf("ppmrdonlyread%dof%d.",ii,rows*cols);hxe();}break;case6:for(ii=0;ii<rows*cols;ii++){fread(&tstr,1,3,f);x[ii]=(double)tstr[0]*65536.+(double)tstr[1]*256.+(double)tstr[2];}break;default:printf("ppmrdcan'treadtype%d.\n",type);hxe();break;}returncols;}ENDVERBATIMVERBATIMstaticdoubleppmwr(void*vv){intcode,ii,type,num,maxsz,rows,cols,max;unsignedchara[3],err;chartstr[256];double*x;FILE*f;num=vector_instance_px(vv,&x);f=hoc_obj_file_arg(1);cols=(int)*getarg(2);if(ifarg(3))type=(int)*getarg(3);elsetype=6;ROWS=rows=num/cols;err=0;fprintf(f,"P%d\n",type);fprintf(f,"#CREATOR:NEURONppmwr%s%s\n","$Date:2010/05/1015:14:46$","$Revision:1.64$");fprintf(f,"%d%d\n",cols,rows);printf("Saving%drowsx%dcols\n",rows,cols);max=255;fprintf(f,"%d\n",max);for(ii=0;ii<num&&!err;ii++){a[0]=(short)(x[ii]/65536);a[1]=(short)((x[ii]-(double)a[0]*65536.)/256.);a[2]=(short)(x[ii]-(double)a[0]*65536.-(double)a[1]*256.);switch(type){case6:fwrite(&a,1,3,f);break;case3:fprintf(f,"%d%d%d",a[0],a[1],a[2]);if(ii%6==0)fprintf(f,"\n");break;default:printf("ppmrdcan'treadtype%d.\n",type);hxe();err=1;break;}}fflush(f);returnii;}ENDVERBATIMVERBATIMstaticdoublergb(void*vv){inti,j,nx,nr,ng,nb,rows,cols,flag;double*x,*r,*g,*b;nx=vector_instance_px(vv,&x);nr=vector_arg_px(1,&r);ng=vector_arg_px(2,&g);nb=vector_arg_px(3,&b);if(nr!=nx||ng!=nx||nb!=nx){printf("ERRrgb()sizemismatch\n");hxe();}if(ifarg(4)){for(i=0;i<nx;i++)x[i]=r[i]*65536.+g[i]*256.+b[i];}elsefor(i=0;i<nx;i++){r[i]=floor(x[i]/65536.);g[i]=floor((x[i]-r[i]*65536.)/256.);b[i]=x[i]-r[i]*65536.-g[i]*256.;}return0.0;}ENDVERBATIMVERBATIMstaticdoublemget(void*vv){inti,j,nx,rows,cols;double*x;nx=vector_instance_px(vv,&x);i=(int)*getarg(1);j=(int)*getarg(2);COLS=cols=(ifarg(3))?(int)*getarg(3):(int)COLS;if(i*cols+j>=nx){hoc_execerror("Indicesoutofbounds",0);}returnx[i*cols+j];}ENDVERBATIMVERBATIMstaticdoublemrow(void*vv){inti,j,nx,ny,rows,cols;double*x,*y;nx=vector_instance_px(vv,&x);ny=vector_arg_px(1,&y);i=(int)*getarg(2);COLS=cols=(ifarg(3))?(int)*getarg(3):(int)COLS;ROWS=rows=ny/cols;if(i>=rows){hoc_execerror("Indicesoutofbounds",0);}if(cols!=nx)x=vector_newsize((IvocVect*)vv,nx=cols);for(j=0;j<nx;j++){x[j]=y[i*cols+j];}returnnx;}ENDVERBATIMVERBATIMstaticdoublemcol(void*vv){inti,j,nx,ny,rows,cols;double*x,*y;nx=vector_instance_px(vv,&x);ny=vector_arg_px(1,&y);j=(int)*getarg(2);COLS=cols=(ifarg(3))?(int)*getarg(3):(int)COLS;if(j>=cols){hoc_execerror("Indicesoutofbounds",0);}ROWS=rows=ny/cols;if(rows!=nx)x=vector_newsize((IvocVect*)vv,nx=rows);for(i=0;i<nx;i++){x[i]=y[i*cols+j];}returnnx;}ENDVERBATIMVERBATIMstaticdoublemsetrow(void*vv){inti,j,nx,ny,rows,cols;double*x,*y;nx=vector_instance_px(vv,&x);ny=vector_arg_px(1,&y);i=(int)*getarg(2);COLS=cols=(ifarg(3))?(int)*getarg(3):(int)COLS;if(cols!=nx||i>=ny/cols){hoc_execerror("Indicesoutofbounds",0);}for(j=0;j<nx;j++){y[i*cols+j]=x[j];}returnnx;}ENDVERBATIMVERBATIMstaticdoublemsetcol(void*vv){inti,j,nx,ny,rows,cols;double*x,*y;nx=vector_instance_px(vv,&x);ny=vector_arg_px(1,&y);j=(int)*getarg(2);COLS=cols=(ifarg(3))?(int)*getarg(3):(int)COLS;if(cols!=ny/nx||j>=cols){hoc_execerror("Indicesoutofbounds",0);}for(i=0;i<nx;i++){y[i*cols+j]=x[i];}returnnx;}ENDVERBATIMVERBATIMstaticdoublemset(void*vv){inti,j,nx,rows,cols;double*x,val;nx=vector_instance_px(vv,&x);i=(int)*getarg(1);j=(int)*getarg(2);COLS=cols=(ifarg(3))?(int)*getarg(3):(int)COLS;val=(ifarg(4))?*getarg(4):*getarg(3);if(i*cols+j>=nx){hoc_execerror("Indicesoutofbounds",0);}return(x[i*cols+j]=val);}ENDVERBATIMVERBATIMtypedefstructRUNT{intleft,right,y,width;}runt;typedefstructRUNL{runt*p;intsz;intbufsz;int*marked;}runl;typedefstructCOMPT{intleft,right,top,bot,pixels,nruns,w,h;int*prun;}compt;typedefstructCOMPL{compt*p;intsz;intbufsz;runl*pruns;}compl_struct;compl_struct*alloccompl(intbufsz,runl*pruns){compl_struct*r;r=(compl_struct*)calloc(1,sizeof(compl_struct));r->sz=0;r->bufsz=bufsz;r->p=(compt*)calloc(bufsz,sizeof(compt));r->pruns=pruns;returnr;}voidaddcomp(compl_struct*pc,intmaxruns){if(pc->sz+1>=pc->bufsz){pc->bufsz*=10;pc->p=(compt*)realloc(pc->p,pc->bufsz*sizeof(compt));}memset(&pc->p[pc->sz],0,sizeof(compt));pc->p[pc->sz].prun=(int*)calloc(maxruns,sizeof(int));pc->sz++;}voidfreecompl(compl_struct**cc){compl_struct*c;inti;c=cc[0];for(i=0;i<c->sz;i++)free(c->p[i].prun);free(c->p);cc[0]=0x0;}voidaddruntocomp(compl_struct*pc,intcidx,intridx){compt*c;c=&pc->p[cidx];c->prun[c->nruns]=ridx;if(pc->pruns->p[ridx].left<c->left)c->left=pc->pruns->p[ridx].left;if(pc->pruns->p[ridx].right>c->right)c->right=pc->pruns->p[ridx].right;if(pc->pruns->p[ridx].y<c->top)c->top=pc->pruns->p[ridx].y;if(pc->pruns->p[ridx].y>c->bot)c->bot=pc->pruns->p[ridx].y;c->w=c->right-c->left+1;c->h=c->bot-c->top+1;c->pixels+=pc->pruns->p[ridx].width;c->nruns++;}runl*allocrunl(intbufsz){runl*r;r=(runl*)calloc(1,sizeof(runl));r->sz=0;r->bufsz=bufsz;r->p=(runt*)calloc(bufsz,sizeof(runt));r->marked=(int*)calloc(bufsz,sizeof(int));returnr;}voidfreerunl(runl**rr){runl*r;r=rr[0];free(r->p);free(r);free(r->marked);rr[0]=0x0;}voidaddrun(runl*pr,intleft,intright,inty){intoldsz,i;oldsz=pr->bufsz;if(pr->sz+1>=oldsz){pr->bufsz*=10;pr->p=(runt*)realloc(pr->p,pr->bufsz*sizeof(runt));pr->marked=(int*)realloc(pr->marked,pr->bufsz*sizeof(int));for(i=oldsz;i<pr->bufsz;i++)pr->marked[i]=0;}pr->p[pr->sz].left=left;pr->p[pr->sz].right=right;pr->p[pr->sz].width=right-left+1;pr->p[pr->sz].y=y;pr->sz+=1;}runl*findruns(double*pin,introws,intcols){inti,x,y,right,left,bufsz;runl*pr;bufsz=1000;pr=allocrunl(bufsz);for(y=0;y<rows;y++){for(x=0;x<cols;x++){if(pin[y*cols+x]){right=left=x;for(right=x;right<cols&&pin[y*cols+right];right++);if(right==cols)right=cols-1;for(left=x;left>=0&&pin[y*cols+left];left--);if(left<0)left=0;addrun(pr,left,right,y);}}}returnpr;}intvintrunts(runt*r1,runt*r2){return!(r1->left>r2->right||r2->left>r1->right)&&abs(r1->y-r2->y)==1;}voidfloodruns(compl_struct*pc,intridx,intcidx){inti;runl*pr;pr=pc->pruns;if(pr->marked[ridx])return;addruntocomp(pc,cidx,ridx);pr->marked[ridx]=1;for(i=ridx-1;i>=0;i--){if(pr->p[ridx].y-pr->p[i].y>1)break;if(vintrunts(&pr->p[i],&pr->p[ridx]))floodruns(pc,i,cidx);}for(i=ridx+1;i<pr->sz;i++){if(pr->p[i].y-pr->p[ridx].y>1)break;if(vintrunts(&pr->p[i],&pr->p[ridx]))floodruns(pc,i,cidx);}}compl_struct*findcomps(runl*pruns){compl_struct*pc;inti,j,cidx;runt*r1,*r2;pc=alloccompl(1000,pruns);for(i=0;i<pruns->sz;i++){if(pruns->marked[i])continue;cidx=pruns->sz;addcomp(pc,pruns->sz);floodruns(pc,i,cidx);}returnpc;}staticdoubleccomps(void*vv){intx,y,rows,cols,szin,szout;double*pin,*plab,val;runl*pr;compl_struct*pc;szin=vector_instance_px(vv,&pin);szout=vector_arg_px(1,&plab);COLS=cols=(int)*getarg(3);ROWS=rows=szin/cols;if(szin!=szout){printf("ccompsERRA:inputmustbesamesizeasoutput(%d,%d)\n",szin,szout);return0.0;}pr=findruns(pin,rows,cols);pc=findcomps(pr);freerunl(&pr);freecompl(&pc);return1.0;}ENDVERBATIMPROCEDUREinstall_matrix(){if(MATRIX_INSTALLED==0){MATRIX_INSTALLED=1VERBATIMinstall_vector_method("outprod",outprod);install_vector_method("mmult",mmult);install_vector_method("spmult",spmult);install_vector_method("spget",spget);install_vector_method("mkspcp",mkspcp);install_vector_method("chkspcp",chkspcp);install_vector_method("spltp",spltp);install_vector_method("transpose",transpose);install_vector_method("revrows",revrows);install_vector_method("mprintf",mprintf);install_vector_method("mshuffle",mshuffle);install_vector_method("mget",mget);install_vector_method("mset",mset);install_vector_method("mrow",mrow);install_vector_method("mcol",mcol);install_vector_method("msetrow",msetrow);install_vector_method("msetcol",msetcol);install_vector_method("sector",sector);install_vector_method("ppmrd",ppmrd);install_vector_method("ppmwr",ppmwr);install_vector_method("rgb",rgb);install_vector_method("symmclean",symmclean);install_vector_method("ccomps",ccomps);ENDVERBATIM}else{printf("%s\n","$Id}